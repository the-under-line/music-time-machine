<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Spotify Time Traveler (Billboard)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <py-config>
      [[runtimes]]
      src = "runtime/pyodide.js"
      name = "pyodide-0.21.3"
      lang = "python"
    </py-config>
    <link rel="icon" type="icons/png" href="/icon-128.png" />
    <link rel="stylesheet" href="popup.css" />
    <link rel="stylesheet" href="runtime/pyscript.css" />
    <script defer src="runtime/pyscript.js"></script>
  </head>
  <body>
    <h2>Welcome to the Games Co.</h2>
    <h3>Sponsored by The UnderLine</h3>
<py-script> 
from js import document as popup  # DOM for this popup page
from datetime import datetime
game_choice = input("Choose a game. \n1. Snake Game\n2. Pong\n3.Crossy Road\n4. Shoot the Turtles\nType 1, 2, 3, or 4: ")

from turtle import Turtle, Screen
import random
COLORS = ["red", "orange", "yellow", "green", "blue", "purple", "pink"]

class Food(Turtle):

    def __init__(self):
        super().__init__()
        self.shape("circle")
        self.penup()
        self.shapesize(0.5, 0.5)
        self.speed("fastest")
        self.refresh()

    def check_distance(self, predator, prey):
        if predator.head.distance(prey) < 15:
            self.refresh()
            predator.extend()

            return True


    def refresh(self):
        self.color(random.choice(COLORS))
        random_x = random.randint(-280, 280)
        random_y = random.randint(-280, 280)
        self.goto(random_x, random_y)

ALIGNMENT = "center"
FONT = ("Courier", 20, "normal")

class Scoreboard(Turtle):
    def __init__(self):
        super().__init__()
        self.hideturtle()
        self.score = 0
        self.high_score = 0
        self.get_high_score()
        self.color("white")
        self.penup()
        self.sety(260)

    def display_score(self):
        self.clear()
        self.write(arg=f"Score: {self.score}, High Score: {self.high_score}", align=ALIGNMENT, font=FONT)
    def get_high_score(self):
        with open("data.txt") as data:
            self.high_score = int(data.read())
    def update_high_score(self):
        if self.score > int(self.high_score):
            with open("data.txt", mode="w") as data:
                data.write(str(self.score))
            self.get_high_score()

    def increase_score(self, condition):
        if condition:
            self.score += 1
        self.update_high_score()

    def reset(self):
        self.score = 0
        self.display_score()

    def game_over(self):
        self.goto(0,0)
        self.write(arg=f"GAME OVER", align=ALIGNMENT, font=("Courier", 30, "normal"))

MOVE_DISTANCE = 20
UP = 90
DOWN = 270
LEFT = 180
RIGHT = 0

turtle_x = 0

class Snake:
    def __init__(self):
        self.segments = []
        self.create_snake()
        self.head = self.segments[0]

    def add_segment(self, position):
        segment = Turtle(shape="square")
        segment.color("white")
        segment.penup()
        segment.goto(position)
        self.segments.append(segment)

    def create_snake(self):
        for x in range(3):
            global turtle_x

            self.add_segment((turtle_x, 0))
            turtle_x -= 20

    def reset(self):
        for segment in self.segments:
            segment.teleport(1000, 1000)
        self.segments.clear()
        self.__init__()

    def move(self):
        for seg_num in range(len(self.segments) - 1, 0, -1):
            new_x = self.segments[seg_num - 1].xcor()
            new_y = self.segments[seg_num - 1].ycor()
            self.segments[seg_num].goto(new_x, new_y)
        self.head.forward(MOVE_DISTANCE)

    def up(self):
        if self.head.heading() != DOWN:
            self.head.setheading(UP)
    def down(self):
        if self.head.heading() != UP:
            self.head.setheading(DOWN)
    def left(self):
        if self.head.heading() != RIGHT:
            self.head.setheading(LEFT)
    def right(self):
        if self.head.heading() != LEFT:
            self.head.setheading(RIGHT)

    def hit_wall(self):
        if self.head.xcor() > 300 or self.head.xcor() < -300 or self.head.ycor() > 300 or self.head.ycor() < -300:
            return True


    def extend(self):
        self.add_segment(self.segments[-1].position())

    def detect_collision(self):
        for segment in self.segments[1:]:
            if self.head.distance(segment) < 10:
                return True

def snake_game():
    import time

    screen = Screen()
    screen.setup(width=600, height=600)
    screen.bgcolor("black")
    screen.title("Slithering Snake - A Game")
    screen.tracer(0)

    snake = Snake()
    food = Food()
    scoreboard = Scoreboard()

    screen.listen()
    screen.onkeypress(key="w", fun=snake.up)
    screen.onkeypress(key="s", fun=snake.down)
    screen.onkeypress(key="a", fun=snake.left)
    screen.onkeypress(key="d", fun=snake.right)
    screen.onkeypress(key="Up", fun=snake.up)
    screen.onkeypress(key="Down", fun=snake.down)
    screen.onkeypress(key="Left", fun=snake.left)
    screen.onkeypress(key="Right", fun=snake.right)

    game_is_on = True
    while game_is_on:
        screen.update()
        time.sleep(0.1)
        snake.move()
        scoreboard.increase_score(food.check_distance(predator=snake, prey=food))
        scoreboard.display_score()
        if snake.hit_wall() or snake.detect_collision():
            snake.reset()
            scoreboard.reset()

    screen.exitonclick()


from random import choice

class Ball(Turtle):
    def __init__(self):
        super().__init__()
        self.shape("circle")
        self.penup()
        self.color("white")
        self.y_move = 10
        self.x_move = 10
        self.move_speed = 0.08

    def move(self):
        new_x = self.xcor() + self.x_move
        new_y = self.ycor() + self.y_move
        self.goto(x=new_x, y=new_y)

    def detect_collision_wall(self):
        if self.ycor() > 280 or self.ycor() < -280:
            self.y_move *= -1

    def detect_collision_paddle(self, paddle_r, paddle_l):
        if (self.distance(paddle_r) < 50 and self.xcor() > 320
                or self.distance(paddle_l) < 50 and self.xcor() < -320):
            self.move_speed *= 0.9
            self.x_move *= -1
        elif self.xcor() > 410:
            self.goto(0,0)
            options = [-1, 1]
            self.x_move *= -1
            self.y_move *= choice(options)
            self.move_speed = 0.08
            return "l_paddle"
        elif self.xcor() < -410:
            self.goto(0,0)
            options = [-1, 1]
            self.x_move *= -1
            self.y_move *= choice(options)
            self.move_speed = 0.08
            return "r_paddle"

class Scoreboard_p(Turtle):
    def __init__(self):
        super().__init__()
        self.color("white")
        self.hideturtle()
        self.penup()
        self.l_score = 0
        self.r_score = 0

    def write_score(self):
        self.clear()
        self.goto(-100, 200)
        self.write(self.l_score, align="center", font=("Courier", 80, "normal"))
        self.goto(100, 200)
        self.write(self.r_score, align="center", font=("Courier", 80, "normal"))

class Paddle(Turtle):
    def __init__(self, x_cor):
        super().__init__()
        self.shape("square")
        self.penup()
        self.shapesize(stretch_wid=5, stretch_len=1)
        self.color("white")
        self.setx(x_cor)
        self.color("white")


    def move_up(self):
        self.sety(self.ycor() + 20)

    def move_down(self):
        self.sety(self.ycor() - 20)
import time
def pong():
    screen = Screen()
    screen.setup(width=800, height=600)
    screen.bgcolor("black")
    screen.title("Pong")

    screen.tracer(0)
    r_paddle = Paddle(x_cor=350)
    l_paddle = Paddle(x_cor=-350)

    screen.listen()

    screen.onkeypress(fun=r_paddle.move_up, key="Up")
    screen.onkeypress(fun=r_paddle.move_down, key="Down")
    screen.onkeypress(fun=l_paddle.move_up, key="w")
    screen.onkeypress(fun=l_paddle.move_down, key="s")

    ball = Ball()

    scoreboard = Scoreboard_p()

    is_on = True
    while is_on:
        scoreboard.write_score()
        time.sleep(ball.move_speed)
        screen.update()
        ball.move()
        ball.detect_collision_wall()
        point = ball.detect_collision_paddle(paddle_r=r_paddle, paddle_l=l_paddle)
        if point == "r_paddle":
            scoreboard.r_score += 1
        elif point == "l_paddle":
            scoreboard.l_score += 1

    screen.exitonclick()

COLORS_car = ["red", "orange", "yellow", "green", "blue", "purple"]
STARTING_MOVE_DISTANCE = 5
MOVE_INCREMENT = 10


class CarManager:
    def __init__(self):
        self.cars = []
    def generate_cars(self):
        new_car = Turtle(shape="square")
        new_car.penup()
        new_car.shapesize(stretch_wid=1, stretch_len=2)
        new_car.color(random.choice(COLORS_car))
        new_car.goto(x=300, y=random.randint(a=-260, b=250))
        self.cars.append(new_car)
        new_car.setheading(180)
    def move_cars(self, level):
        for car in self.cars:
            distance = STARTING_MOVE_DISTANCE
            for x in range(level - 1):
                distance += MOVE_INCREMENT
            car.forward(distance)

STARTING_POSITION = (0, -280)
MOVE_DISTANCE_car = 10
FINISH_LINE_Y = 280


class Player(Turtle):
    def __init__(self):
        super().__init__()
        self.died = False
        self.shape("turtle")
        self.penup()
        self.setheading(90)
        self.goto(STARTING_POSITION)
    def move_forward(self):
        self.forward(MOVE_DISTANCE_car)
    def beats_level(self):
        if self.ycor() > FINISH_LINE_Y:
            self.goto(STARTING_POSITION)
            return True
    def hit_car(self, car_list):
        for car in car_list:
            if self.distance(car) < 20:
                self.died = True
                return True

FONT_car = ("Courier", 24, "normal")


class Scoreboard_car(Turtle):
    def __init__(self):
        super().__init__()
        self.level = 1
        self.penup()
        self.hideturtle()
        self.goto(x=-280, y=260)
    def display_level(self):
        self.clear()
        self.write(arg=f"Level: {self.level}", align="left", font=FONT_car)
    def game_over(self):
        self.goto(0,0)
        self.write(arg="GAME OVER", align="center", font=FONT_car)

def crossy_road():
    screen = Screen()
    screen.setup(width=600, height=600)
    screen.tracer(0)

    car_manager = CarManager()
    player = Player()

    game_is_on = True
    screen.listen()

    scoreboard = Scoreboard_car()

    loop = 0
    while game_is_on:
        time.sleep(0.1)
        screen.update()
        scoreboard.display_level()
        if loop % 6 == 0:
            car_manager.generate_cars()
        car_manager.move_cars(scoreboard.level)
        screen.onkeypress(fun=player.move_forward, key="w")
        screen.onkeypress(fun=player.move_forward, key="Up")
        if player.hit_car(car_manager.cars):
            game_is_on = False
            scoreboard.game_over()
        if player.beats_level():
            scoreboard.level += 1

        loop += 1

    screen.exitonclick()

class BulletMaker:
    def __init__(self):
        self.bullets = []

    def create_bullet(self, player):
        new_bullet = Turtle(shape="circle")
        new_bullet.shapesize(stretch_wid=0.25, stretch_len=0.25)
        new_bullet.color("white")
        new_bullet.penup()
        self.bullets.append(new_bullet)
        new_bullet.goto(player.position())

    def move_bullets(self):
        for bullet in self.bullets:
            bullet.forward(20)

    def detect_collision(self, targets):
        for bullet in self.bullets:
            for target in targets:
                if bullet.distance(target) < 20:
                    return targets.index(target)
        return "False"
class Player_shoot(Turtle):
    def __init__(self):
        super().__init__()
        self.color("white")
        self.penup()
        self.goto(x=-320, y=0)

    def move_up(self):
        self.sety(self.ycor() + 10)
    def move_down(self):
        self.sety(self.ycor() - 10)

SPEED = 1.5
MOVE_INCREMENT_shoot = 1.5
START_LIVES = 1
LIVES_INCREMENT = 2

class AttackManager:
    def __init__(self):
        self.attackers = []
        self.start_y = 100
        self.attacker_lives = START_LIVES
        global SPEED
        self.speed = SPEED
        self.display_lives = 1
        self.attackers_died = 0

    def turtle_wave(self):
        for x in range(5):
            new_turtle = Turtle(shape="turtle")
            new_turtle.color("green")
            new_turtle.penup()
            new_turtle.goto(x=320, y=self.start_y)
            new_turtle.setheading(180)
            new_turtle.lives = self.attacker_lives
            self.attackers.append(new_turtle)
            self.start_y -= 50
    def move_turtles(self):
        for attacker in self.attackers:
            attacker.forward(self.speed)

    def check_level_complete(self):
        if len(self.attackers) == 0:
            return True
        else:
            return False

    def attacker_death(self, shot_index):
        if self.attackers[shot_index].lives == 1:
            self.attackers[shot_index].goto(1000,1000)
            del self.attackers[shot_index]
            self.attackers_died += 1
        else:
            self.attackers[shot_index].lives -= 1

    def level_up(self, new_level):
        self.start_y = 100
        if new_level % 2 == 0:
            global MOVE_INCREMENT_shoot
            self.speed += MOVE_INCREMENT_shoot
        else:
            self.attacker_lives += LIVES_INCREMENT
        self.turtle_wave()

    def game_over(self):
        for attacker in self.attackers:
            if attacker.xcor() < -320:
                return True
FONT_shoot = ("Courier", 30)

class Scoreboard_shoot(Turtle):
    def __init__(self):
        super().__init__()
        self.color("white")
        self.hideturtle()
        self.penup()
        self.goto(x=0, y=160)
        self.level = 1
        self.high_score = 0
        self.get_high_score()

    def display_level(self, turtles_killed):
        self.clear()
        self.update_high_score()
        self.write(f"Level: {self.level}, High Score: {self.high_score}, Turtles Killed: {turtles_killed}", align="center", font=FONT_shoot)

    def level_up(self):
        self.level += 1
        self.update_high_score()

    def game_over(self, turtles_killed):
        self.clear()
        self.display_level(turtles_killed)
        self.goto(0,0)
        self.write("GAME OVER", align="center", font=FONT_shoot)

    def get_high_score(self):
        with open("high_score.txt") as data:
            self.high_score = int(data.read())

    def update_high_score(self):
            if self.level > self.high_score:
                self.high_score = self.level
                with open("high_score.txt", mode="w") as data:
                    data.write(str(self.high_score))
                self.get_high_score()

def shoot_the_turtles():
    screen = Screen()
    screen.bgcolor("black")
    screen.setup(800, 400)
    screen.title("Shoot the Turtles!")

    screen.textinput(title="How To Play",
                     prompt="Rules:\n1) Shoot as many turtles as you can before they can go past you."
                            "\n2) If a turtle goes past where you are, you die."
                            "\n3) As the game goes on, the turtles gain speed and lives. "
                            "\nIf you hit a turtle on a leg, you remove one life, "
                            "if you hit it straight down the middle, you remove two lives!"
                            "\nWhen you are ready, type 'okay' in the box below.")

    screen.tracer(0)

    attack_manager = AttackManager()
    attack_manager.turtle_wave()

    user = Player_shoot()

    scoreboard = Scoreboard_shoot()

    game_is_on = True
    bullet_manager = BulletMaker()

    def shoot():
        bullet_manager.create_bullet(player=user)

    screen.listen()
    while game_is_on:
        time.sleep(0.1)
        screen.update()
        scoreboard.display_level(turtles_killed=attack_manager.attackers_died)
        screen.onkeypress(key="w", fun=user.move_up)
        screen.onkeypress(key="Up", fun=user.move_up)
        screen.onkeypress(key="s", fun=user.move_down)
        screen.onkeypress(key="Down", fun=user.move_down)
        screen.onkeypress(key="Right", fun=shoot)
        screen.onkeypress(key="d", fun=shoot)
        bullet_manager.move_bullets()
        turtle_shot = bullet_manager.detect_collision(targets=attack_manager.attackers)
        if turtle_shot != "False":
            attack_manager.attacker_death(turtle_shot)
            if attack_manager.check_level_complete():
                scoreboard.level_up()
                attack_manager.level_up(scoreboard.level)
        if attack_manager.game_over():
            scoreboard.game_over(attack_manager.attackers_died)
            game_is_on = False
        attack_manager.move_turtles()

    screen.exitonclick()

if game_choice == "1":
    snake_game()
elif game_choice == "2":
    pong()
elif game_choice == "3":
    crossy_road()
else:
    shoot_the_turtles()


</py-script>
  </body>
</html>

